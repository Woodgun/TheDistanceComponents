<!DOCTYPE html>
<html lang="en">
  <head>
    <title>TDCContentLoading  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="TDCContentLoading  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">TDCContentLoading Docs</a> (98% documented)</p>
        <p class="header-right"><a href="https://github.com/thedistance/TheDistanceComponents"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">TDCContentLoading Reference</a>
        <img id="carat" src="img/carat.png" />
        TDCContentLoading  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/ContentLoadingViewModel.html">ContentLoadingViewModel</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ListLoadingViewModel.html">ListLoadingViewModel</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/PagingContentLoadingViewModel.html">PagingContentLoadingViewModel</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ReactiveAppearanceViewController.html">ReactiveAppearanceViewController</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Enums.html">Enums</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/ContentLoadingState.html">ContentLoadingState</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ViewLifetime.html">ViewLifetime</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/Array.html">Array</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/ChangesetLoadingModel.html">ChangesetLoadingModel</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ContentEquatable.html">ContentEquatable</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ListLoadingContainer.html">ListLoadingContainer</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ListLoadingModel.html">ListLoadingModel</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structs</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/Changeset.html">Changeset</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/PagedOutput.html">PagedOutput</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Typealiases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:E17TDCContentLoadingSa9ValueType">ValueType</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <a href='#tdccontentloading' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='tdccontentloading'>TDCContentLoading</h1>

<p>Consistent Asynchronous Loading</p>

<p>This is a sub-framework of a <a href="https://github.com/thedistance/thedistancecomponents">TheDistanceComponents</a>.  There are more sub-frameworks adding extra functionality and a whole lot more planned, including UI for Content Loaders.</p>
<a href='#features' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='features'>Features</h2>

<ul>
<li>[x] Standard StateModel &amp; ViewModel for handling network requests in MVVM</li>
<li>[x] View Lifetime properties delivered using ReactiveCocoa</li>
<li>[x] Standardised cases for List Loading including paging content</li>
</ul>
<a href='#dependencies' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='dependencies'>Dependencies</h2>

<ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a></li>
</ul>
<a href='#getting-started' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='getting-started'>Getting Started</h2>

<p>TDCContentLoading is based around a ViewModel object: <a href=""><code>ContentLoadingViewModel</code></a>. The definition might appear convoluted at first glance, however asynchronous loading becomes very trivial if you just subclasses the necesseary methods:</p>

<ol>
<li><p>Define the type of content you will be loading:</p>

<p>class MyModel { &hellip; }</p></li>
<li><p>Create a subclass of <code>ContentLoadingViewModel</code> typed to your output and override <code>loadingProducerWithInput(_:)</code> to return a <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> SignalProducer that loads your content (<a href="https://github.com/joshc89/ReactiveCocoaConvenience">ReactiveCocoaConvenience</a> provides simple APIs for this):</p>

<p>class MyContentLoader : ContentLoadingViewModel<Void, MyModel> { </p>
<pre class="highlight plaintext"><code>   func loadingProducerWithInput(input: Void?) -&gt; SignalProducer&lt;MyModel, NSError&gt; {
       return Alamofire.Get("https://api.mysite/get/my/model")
         .validate()
         .rac_responseSwiftyJSONCreated()
   }
</code></pre>

<p>}</p></li>
<li><p>Bind any UI properties in your <code>UIViewController</code> (or other View object) to the Output Properties of your <code>ContentLoadingViewModel</code>:</p>

<p>let viewModel = MyContentLoader()</p>

<p>override func viewDidLoad(animated:Bool)  {
       super.viewDidLoad(animated)</p>
<pre class="highlight plaintext"><code>   errorLabel.rac_text &lt;~ viewModel.errorSignal.map { $0.localizedDescription }
   loadingView.rac_hidden &lt;~ viewModel.isLoading.signal.map { !$0 }

   viewModel.contentChangesSignal.observeNext { newValue in
       // Update the UI
       ...
   }
</code></pre>

<p>}</p></li>
<li><p>Trigger loading by sending <code>.Next(_)</code> events:</p>

<p>func buttonTapped() {
       viewModel.refreshObsever.sendNext(_)
   }</p></li>
</ol>

<p>For a simple ViewModel example see <a href=""><code>TDCContentLoadingTests.swift</code></a>.
A consistent structure for UI based on <code>ContentLoadingViewModel</code> is coming soon. This set up was inspired by <a href="http://www.martinrichter.net/">Martin Richter&rsquo;s excellent blog series about MVVM in iOS using ReactiveCocoa</a>. An indepth look at how <code>ContentLoadingViewModel</code> works is given below.</p>
<a href='#lists-amp-paging' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='lists-amp-paging'>Lists &amp; Paging</h3>

<p><em>More detail to come soon&hellip;</em></p>
<a href='#contentloadingview-model-in-depth' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='contentloadingview-model-in-depth'>ContentLoadingView Model In Depth</h2>
<a href='#content-loading' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='content-loading'>Content Loading</h3>

<p>This component is for fetching and serialising content asynchronously and reporting the progress in a standard way. Rather than considering fetching data from a network, think instead of the entire process from user interaction to beginning the request, showing loading is ongoing, and reporting a successful serialized Model object or a failure. </p>
<a href='#state-changes' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='state-changes'>State Changes</h4>

<p>The loading process is represented by the <a href=""><code>ContentLoadingState</code></a> enum.</p>
<pre class="highlight plaintext"><code>public enum ContentLoadingState&lt;ValueType&gt; {

    /// No fetch has been initiated yet.
    case Unloaded

    /// Content has been requested successfully but nothing is found
    case Empty

    /// A network request is currently in progress.
    case Loading

    /// A request has successfully completed with content.
    case Success(ValueType)

    /// A request has failed with the given error.
    case Error(NSError)
}
</code></pre>

<p>The <a href=""><code>ContentLoadingViewModel</code></a> is the ViewModel object used to manage asynchronous loading, typically started as a result of user interaction in a View. It sends <code>ContentLoadingState</code> updates through <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> signals on the <code>state</code> property. If elements of the View are only interested in a single state, they can observe the individual properties:</p>

<ul>
<li><code>isLoading</code></li>
<li><code>contentChangesSignal</code></li>
<li><code>errorSignal</code></li>
</ul>

<p>The request is triggered by sending an event to the <code>refreshObserver</code> which starts the SignalProducer returned from <code>loadingProducerWithInput(_:)</code>, which subclasses should override. This sets:</p>

<ul>
<li><code>isLoading -&gt; true</code></li>
<li><code>state -&gt; .Loading</code></li>
</ul>

<p>The SignalProducer returned from <code>loadingProducerWithInput(_:)</code> could initiate a network request (<a href="https://github.com/joshc89/ReactiveCocoaConvenience">ReactiveCocoaConvenience</a> provides simple APIs for this) or other form of loading.</p>

<p>If that SignalProducer fails, the error is sent through the <code>errorSignal</code> property on the <code>ContentLoadingViewModel</code> and</p>

<ul>
<li><code>isLoading -&gt; false</code></li>
<li><code>state -&gt; .Error(_)</code></li>
</ul>

<p>The networking error as is the state&rsquo;s associated value.</p>

<p>If the request succeeds, the new value is sent through the <code>contentChangesSignal</code>. The result is tested for being &lsquo;empty&rsquo; using <code>contentIsEmpty(_:)</code>, which subclasses should override. The <code>.Empty</code> state is explicitly defined as UI will often differ to show the user that there is nothing there, rather than a blank list with no context.</p>

<p>If <code>contentIsEmpty(_:) == true</code>:</p>

<ul>
<li><code>isLoading -&gt; false</code></li>
<li><code>state -&gt; .Empty</code></li>
</ul>

<p>else </p>

<ul>
<li><code>isLoading -&gt; false</code></li>
<li><code>state -&gt; .Success(_)</code></li>
</ul>

<p>The associated value of the <code>.Success(_)</code> state is the associated value of the <code>.Next(_)</code> event of the <code>SignalProducer</code> from returned from <code>loadingProducerWithInput(_:)</code>.</p>
<a href='#view-lifetime-events' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='view-lifetime-events'>View Lifetime Events</h4>

<p><code>ContentLoadingViewModel</code> has a property that can be bound to the <code>ViewLifetimeSignal</code> of a <code>ReactiveAppearanceViewController</code>:</p>
<pre class="highlight plaintext"><code>let viewLifetime = MutableProperty&lt;ViewLifetime&gt;(.Init)
</code></pre>

<p>This is used to observer changes on the View object this ViewModel is providing logic for. It is also initialised with an optional <code>ViewLifetime</code> parameter. When the values of the <code>viewLifetime</code> property changes, if it equals this parameter a refresh is triggered. This is useful for triggering or cancelling requests on view lifecycle events such as <code>viewWillAppear(_:)</code> and <code>viewDidDisappear(_:)</code>.</p>
<a href='#testing-content-loaders' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='testing-content-loaders'>Testing Content Loaders</h3>

<p>A major goal for <a href="https://github.com/thedistance/thedistancecomponents">TheDistanceComponents</a> is to increase testability, part of which is testing Model objects are initialised correctly from the data fetched. </p>

<p>To provide the flexibility to mock API responses, first define a <code>URLStore</code> - a uniqure-per-app protocol defining all the required URLs. </p>
<pre class="highlight plaintext"><code>protocol URLStore {
    var eventListURL: NSURL { get }
}
</code></pre>

<p>An <code>APIManager</code> should then have an <code>init(urlStore:URLStore)</code> initialiser so the endpoints aren&rsquo;t hard-coded in the <code>APIManager</code>, this is known as Dependency Injection.</p>
<pre class="highlight plaintext"><code>class APIManager {

    let urlStore:URLStore

    init(urlStore:URLStore) {
        self.urlStore = urlStore
    }

    ...
}
</code></pre>

<p>You can then define a <code>URLStore</code> that provides URLs for local resources, and one that provides network URLs:</p>
<pre class="highlight plaintext"><code>class LiveURLStore {
    let eventListURL = NSURL(string: "https://api.myevents.com/all")
}

class TestURLStore {
    let eventListURL = NSBundle(forClass: TestURLStore.self).URLForResource("TestEventsList", withExtension: "json")!
}
</code></pre>

<p>The <code>APIManager</code> can then define methods to fetch and serialize content independent of whether it is a live or local resource:</p>
<pre class="highlight plaintext"><code>class APIManager {

    ...

    func getAllEvents() -&gt; SignalProducer&lt;(JSON, [Event]), NSError&gt; {

        return Alamofire.GET(urlStore.eventListURL)
          .validate()
          .rac_responseArraySwiftyJSONCreated()
    }
}
</code></pre>

<hr>

<p><em><code>rac_responseArraySwiftyJSONCreated()</code> is a convenience method from <a href="https://github.com/joshc89/ReactiveCocoaConvenience">ReactiveCocoaConvenience</a>, which includes simple methods for using <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> and <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> to serialise network responses into Model objects.</em></p>

<hr>

<p>Depedency Injection is used again in your ViewModel to specify the APIManager that should be used:</p>
<pre class="highlight plaintext"><code>class MyViewModel: ContentLoadingViewModel&lt;Void, [Event]&gt; {

    let apiManager: APIManager

    init(apiManager: APIManager) {
        self.apiManager = APIManager
        ...
    }

    override func loadingProducerWithInput(input: Void?) -&gt; SignalProducer&lt;[Event], NSError&gt; {
        return apiManager.getAllEvents.map { $0.1 }
    }
}
</code></pre>

<p>Finally, in your <code>XCTestCase</code> you will create your <code>APIManager</code> with your test URLs, and <code>MyViewModel</code> with that <code>APIManager</code>:</p>
<pre class="highlight plaintext"><code>class MyTests: XCTestCase {

    let testAPIManager = APIManager(urlStore: TestURLStore() )
    let viewModel: MyViewModel!

    func setUp() {

        // create a new ViewModel for each test so no state is preseverd between tests
        viewModel = MyViewModel(apiManager: testAPIManager)
    }
</code></pre>

<p>To add further flexibility, you can define <code>APIManager</code> as a protocol:</p>
<pre class="highlight plaintext"><code>protocol APIManager {

    init(urlStore: URLStore)

    func getAllEvents() -&gt; SignalProducer&lt;(JSON, [Event]), NSError&gt;
}
</code></pre>

<p>This would allow different implementations of APIManagers, perhaps if different libraries are available on different platforms. </p>
<a href='#communication' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='communication'>Communication</h2>

<p>If you have any queries / suggestions we&rsquo;d love you to get in touch.</p>

<ul>
<li>If you have <strong>found a bug</strong>, open an issue.</li>
<li>If you have <strong>a feature request</strong>, open an issue.</li>
<li>If you <strong>want to contribute</strong>, submit a pull request.</li>
<li>If you&rsquo;d like to <strong>ask a general question</strong>, email us on <a href="mailto:hello+thedistancecomponents@thedistance.co.uk">hello+thedistancecomponents@thedistance.co.uk</a>.</li>
</ul>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2016 <a class="link" href="https://thedistance.co.uk" target="_blank" rel="external">Josh Campion @ The Distance</a>. All rights reserved. (Last updated: 2016-05-28)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.6.2</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
